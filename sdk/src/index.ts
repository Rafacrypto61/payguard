import * as anchor from "@coral-xyz/anchor";
import { Program, AnchorProvider, BN } from "@coral-xyz/anchor";
import { 
  PublicKey, 
  SystemProgram, 
  Connection, 
  Keypair,
  Transaction
} from "@solana/web3.js";
import { 
  TOKEN_PROGRAM_ID, 
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction
} from "@solana/spl-token";
import { createHash } from "crypto";

// IDL will be generated by Anchor build
import { Payguard } from "../target/types/payguard";

export interface Milestone {
  amount: BN;
  description: string;
  status: MilestoneStatus;
}

export enum MilestoneStatus {
  Pending = "pending",
  Submitted = "submitted",
  Approved = "approved",
  Rejected = "rejected",
  Disputed = "disputed",
  Resolved = "resolved"
}

export enum ContractStatus {
  Active = "active",
  Completed = "completed",
  Cancelled = "cancelled",
  Disputed = "disputed"
}

export interface CreateContractParams {
  freelancer: PublicKey;
  tokenMint: PublicKey;
  totalAmount: number;
  milestones: { amount: number; description: string }[];
  description: string;
}

export interface ContractData {
  id: BN;
  client: PublicKey;
  freelancer: PublicKey;
  tokenMint: PublicKey;
  totalAmount: BN;
  releasedAmount: BN;
  milestones: Milestone[];
  status: ContractStatus;
  createdAt: BN;
}

export class PayGuardClient {
  program: Program<Payguard>;
  provider: AnchorProvider;

  constructor(provider: AnchorProvider, programId: PublicKey) {
    this.provider = provider;
    // @ts-ignore - IDL loaded dynamically
    this.program = new Program(IDL, programId, provider);
  }

  /**
   * Get PDA for a contract
   */
  getContractPDA(contractId: BN): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from("contract"), contractId.toArrayLike(Buffer, "le", 8)],
      this.program.programId
    );
  }

  /**
   * Hash a string to 32 bytes (for on-chain storage)
   */
  hashString(str: string): number[] {
    const hash = createHash("sha256").update(str).digest();
    return Array.from(hash);
  }

  /**
   * Create a new escrow contract
   */
  async createContract(params: CreateContractParams): Promise<string> {
    const contractId = new BN(Date.now()); // Simple unique ID
    const [contractPDA] = this.getContractPDA(contractId);

    const milestones = params.milestones.map((m) => ({
      amount: new BN(m.amount),
      description: m.description,
      status: { pending: {} },
      proofHash: null,
      disputeReason: null,
      arbitrationProof: null,
      submittedAt: null,
    }));

    const descriptionHash = this.hashString(params.description);

    const tx = await this.program.methods
      .createContract(
        contractId,
        new BN(params.totalAmount),
        milestones,
        descriptionHash
      )
      .accounts({
        contract: contractPDA,
        client: this.provider.wallet.publicKey,
        freelancer: params.freelancer,
        tokenMint: params.tokenMint,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Fund escrow with tokens
   */
  async fundEscrow(
    contractId: BN,
    amount: number,
    clientTokenAccount: PublicKey,
    escrowVault: PublicKey
  ): Promise<string> {
    const [contractPDA] = this.getContractPDA(contractId);

    const tx = await this.program.methods
      .fundEscrow(new BN(amount))
      .accounts({
        contract: contractPDA,
        client: this.provider.wallet.publicKey,
        clientTokenAccount,
        escrowVault,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .rpc();

    return tx;
  }

  /**
   * Submit milestone completion (freelancer)
   */
  async submitMilestone(
    contractId: BN,
    milestoneIndex: number,
    proofDescription: string
  ): Promise<string> {
    const [contractPDA] = this.getContractPDA(contractId);
    const proofHash = this.hashString(proofDescription);

    const tx = await this.program.methods
      .submitMilestone(milestoneIndex, proofHash)
      .accounts({
        contract: contractPDA,
        freelancer: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Approve milestone and release funds (client)
   */
  async approveMilestone(
    contractId: BN,
    milestoneIndex: number,
    freelancer: PublicKey,
    escrowVault: PublicKey,
    freelancerTokenAccount: PublicKey
  ): Promise<string> {
    const [contractPDA] = this.getContractPDA(contractId);

    const tx = await this.program.methods
      .approveMilestone(milestoneIndex)
      .accounts({
        contract: contractPDA,
        client: this.provider.wallet.publicKey,
        freelancer,
        escrowVault,
        freelancerTokenAccount,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .rpc();

    return tx;
  }

  /**
   * Raise dispute on a milestone
   */
  async raiseDispute(
    contractId: BN,
    milestoneIndex: number,
    reason: string
  ): Promise<string> {
    const [contractPDA] = this.getContractPDA(contractId);
    const reasonHash = this.hashString(reason);

    const tx = await this.program.methods
      .raiseDispute(milestoneIndex, reasonHash)
      .accounts({
        contract: contractPDA,
        authority: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Get contract data
   */
  async getContract(contractId: BN): Promise<ContractData | null> {
    const [contractPDA] = this.getContractPDA(contractId);
    
    try {
      const contract = await this.program.account.contract.fetch(contractPDA);
      return contract as unknown as ContractData;
    } catch {
      return null;
    }
  }

  /**
   * Get all contracts for a client
   */
  async getClientContracts(client: PublicKey): Promise<ContractData[]> {
    const contracts = await this.program.account.contract.all([
      {
        memcmp: {
          offset: 8 + 8, // discriminator + id
          bytes: client.toBase58(),
        },
      },
    ]);

    return contracts.map((c) => c.account as unknown as ContractData);
  }

  /**
   * Get all contracts for a freelancer
   */
  async getFreelancerContracts(freelancer: PublicKey): Promise<ContractData[]> {
    const contracts = await this.program.account.contract.all([
      {
        memcmp: {
          offset: 8 + 8 + 32, // discriminator + id + client
          bytes: freelancer.toBase58(),
        },
      },
    ]);

    return contracts.map((c) => c.account as unknown as ContractData);
  }
}

// AI Arbitration Module
export class AIArbitrator {
  private apiKey: string;
  private model: string;

  constructor(apiKey: string, model: string = "claude-3-5-sonnet-20241022") {
    this.apiKey = apiKey;
    this.model = model;
  }

  /**
   * Analyze a dispute and return a decision
   */
  async analyzeDispute(params: {
    contractDescription: string;
    milestoneDescription: string;
    deliverableProof: string;
    disputeReason: string;
    additionalContext?: string;
  }): Promise<{
    decision: "favor_freelancer" | "favor_client" | "split";
    splitPercentage?: number;
    reasoning: string;
    confidence: number;
  }> {
    const prompt = `You are an impartial arbitrator for a freelance contract dispute. Analyze the following and provide a fair decision.

CONTRACT DESCRIPTION:
${params.contractDescription}

MILESTONE BEING DISPUTED:
${params.milestoneDescription}

FREELANCER'S PROOF OF COMPLETION:
${params.deliverableProof}

CLIENT'S DISPUTE REASON:
${params.disputeReason}

${params.additionalContext ? `ADDITIONAL CONTEXT:\n${params.additionalContext}` : ""}

Based on this information, determine:
1. Whether the milestone was satisfactorily completed
2. If there's a fair middle ground (partial payment)

Respond in JSON format:
{
  "decision": "favor_freelancer" | "favor_client" | "split",
  "splitPercentage": <number 0-100, only if decision is "split">,
  "reasoning": "<detailed explanation>",
  "confidence": <number 0-1>
}`;

    const response = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey,
        "anthropic-version": "2023-06-01",
      },
      body: JSON.stringify({
        model: this.model,
        max_tokens: 1024,
        messages: [{ role: "user", content: prompt }],
      }),
    });

    const data = await response.json();
    const content = data.content[0].text;
    
    // Parse JSON from response
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error("Failed to parse arbitration response");
    }

    return JSON.parse(jsonMatch[0]);
  }
}

export default PayGuardClient;
